# 알고리즘 과제

퀵정렬을 파이썬에서 구현해 보았다.

### 반복문으로 퀵정렬

```python
import numpy as np
import random
import sys

sys.setrecursionlimit(10 ** 6)
cnt = 0
i_cnt = 0

def ite_quick_sort(A, p, r):  # 배열과 시작과 끝의 인덱스 번호를 받아온다
    if p >= r:  # 원소의 갯수가 1개 이하면 종료
        return
    stack = [0] * (r - p + 1)  # 배열의 크기만큼 스택 정의
    top = -1  # 스택 천장을 의미
    top += 1
    stack[top] = p  # 스택에다가 시작과 끝 인덱스 번호를 저장
    top += 1
    stack[top] = r
    while top >= 0:  # 스택이 빌 때까지 반복
        r = stack[top]
        top -= 1
        p = stack[top]
        top -= 1  # 시작과 끝 인덱스 번호를 스택에서 받아옴

        q = partition(A, p, r)  # 피벗 원소를 기준 으로 분할
        if q - 1 > p:  # 피벗 원소 왼쪽 구역이 존재할 시
            top += 1
            stack[top] = p
            top += 1
            stack[top] = q - 1  # 왼쪽 구역의 시작과 끝 인덱스 번호를 저장

        if q + 1 < r:  # 피벗 원소 오른쪽 구역이 존재할 시
            top += 1
            stack[top] = q + 1
            top += 1
            stack[top] = r  # 오른쪽 구역의 시작과 끝 인덱스 번호를 저장

    # 스택에 홀수번째하고 짝수번째에 각각 구역이 나올 것이고 그 구역 내의 정리가 되면 저장하는 스택이 없어지니 결국 다 빼면서 마무리

def partition(A, p, r):
    piv = r  # 마지막 원소를 피벗 으로
    s = p - 1  # 피벗 보다 작은 원소를 보관할 구역의 마지막 인덱스 번호
    global cnt
    for i in range(r - p):  # 받은 배열의 모든 원소 확인
        cnt += 1
        if A[p + i] <= A[piv]:  # 피벗 보다 작은 원소면
            s += 1
            A[p + i], A[s] = A[s], A[p + i]
    s += 1
    A[r], A[s] = A[s], A[r]  # 피벗 원소를 자신 보다 작은 원소가 있는 구역 오른쪽에 두기
    return s  # 피벗 원소 인덱스 번호를 반환

    # 피벗 원소를 제 자리에 두고 비교연산을 몇번 수행하는지 센다

N = [10 ** 2, 10 ** 4, 10 ** 6]

for i in N:
    for j in range(30):
        A = np.random.rand(i)
        ite_quick_sort(A, 0, len(A) - 1)
        i_cnt += cnt
        cnt = 0
    print(i, "에서의 반복적 퀵정렬 평균 연산 횟수는", i_cnt / 30, "번")
print("프로그램에서의 전체 연산 횟수는", i_cnt , "번")
```

### 재귀적 퀵정렬

```python
import numpy as np
import random
import sys

sys.setrecursionlimit(10 ** 6)
cnt = 0
r_cnt = 0

def rec_quick_sort(A, p, r):  # 배열과 시작과 끝의 인덱스 번호를 받아온다
    if p >= r:  # 원소의 갯수가 1개 이하면 종료
        return
    q = partition(A, p, r)  # 피벗 원소를 기준 으로 분할
    rec_quick_sort(A, p, q - 1)  # 왼쪽 정렬
    rec_quick_sort(A, q + 1, r)  # 오른쪽 정렬

    # 재귀적으로 왼쪽 구역과 오른쪽 구역으로 나눠서 처리한다

def partition(A, p, r):
    piv = r  # 마지막 원소를 피벗 으로
    s = p - 1  # 피벗 보다 작은 원소를 보관할 구역의 마지막 인덱스 번호
    global cnt
    for i in range(r - p):  # 받은 배열의 모든 원소 확인
        cnt += 1
        if A[p + i] <= A[piv]:  # 피벗 보다 작은 원소면
            s += 1
            A[p + i], A[s] = A[s], A[p + i]
    s += 1
    A[r], A[s] = A[s], A[r]  # 피벗 원소를 자신 보다 작은 원소가 있는 구역 오른쪽에 두기
    return s  # 피벗 원소 인덱스 번호를 반환

    # 피벗 원소를 제 자리에 두고 비교연산을 몇번 수행하는지 센다

N = [10 ** 2, 10 ** 4, 10 ** 6]

for i in N:
    for j in range(30):
        A = np.random.rand(i)
        rec_quick_sort(A, 0, len(A) - 1)
        r_cnt += cnt
        cnt = 0
    print(i, "에서의 재귀적 퀵정렬 평균 연산 횟수는", r_cnt / 30, "번")
print("프로그램에서의 전체 연산 횟수는", r_cnt, "번")
```

### 랜덤 피벗 퀵정렬

```python
import numpy as np
import random
import sys

sys.setrecursionlimit(10 ** 6)
cnt = 0
rr_cnt = 0

def partition(A, p, r):
    piv = r  # 마지막 원소를 피벗 으로
    s = p - 1  # 피벗 보다 작은 원소를 보관할 구역의 마지막 인덱스 번호
    global cnt
    for i in range(r - p):  # 받은 배열의 모든 원소 확인
        cnt += 1
        if A[p + i] <= A[piv]:  # 피벗 보다 작은 원소면
            s += 1
            A[p + i], A[s] = A[s], A[p + i]
    s += 1
    A[r], A[s] = A[s], A[r]  # 피벗 원소를 자신 보다 작은 원소가 있는 구역 오른쪽에 두기
    return s  # 피벗 원소 인덱스 번호를 반환

    # 피벗 원소를 제 자리에 두고 비교연산을 몇번 수행하는지 센다

def rr_quick_sort(A, p, r):  # 배열과 시작과 끝의 인덱스 번호를 받아온다
    if p >= r:  # 원소의 갯수가 1개 이하면 종료
        return
    q = r_partition(A, p, r)  # 피벗 원소를 기준 으로 분할
    rr_quick_sort(A, p, q - 1)  # 왼쪽 정렬
    rr_quick_sort(A, q + 1, r)  # 오른쪽 정렬

    # 재귀적으로 왼쪽 구역과 오른쪽 구역으로 나눠서 처리한다

def r_partition(A, p, r):
    pivot = random.randint(p, r)  # 불러온 구역의 인덱스 번호 중에서 골라 피벗 원소의 인덱스 번호로 사용한다.
    A[pivot], A[r] = A[r], A[pivot]  # 랜덤 피벗 원소를 마지막 원소 위치로 옮긴다
    return partition(A, p, r)  # 만들어진 배열로 분할 한다.

N = [10 ** 2, 10 ** 4, 10 ** 6]

for i in N:
    for j in range(30):
        A = np.random.rand(i)
        rr_quick_sort(A, 0, len(A) - 1)
        rr_cnt += cnt
        cnt = 0
    print(i, "에서의 재귀적 랜덤 피벗 퀵정렬 평균 연산 횟수는", rr_cnt / 30, "번")
print("전체 연산 횟수는", rr_cnt, "번")
```

## 결과

각 정렬당 실제 데이터

| ite10^2 | rec10^2 | rr10^2 |     | ite10^4  | rec10^4  | rr10^4   |
| ------- | ------- | ------ | --- | -------- | -------- | -------- |
| 612     | 634.2   | 661.1  |     | 156814.5 | 158763.5 | 156796.7 |
| 649.7   | 607.6   | 684.2  |     | 155964.2 | 157224.9 | 157228.3 |
| 645.1   | 615.6   | 637.9  |     | 154829.6 | 155139.9 | 157090.1 |
| 656.9   | 641.7   | 634.8  |     | 154388.3 | 155418.3 | 158140   |
| 670.4   | 673.8   | 626.9  |     | 156044.2 | 155155   | 157894.7 |
| 637.8   | 644     | 611.7  |     | 154810.5 | 154816.7 | 154869.8 |
| 653.4   | 661.1   | 679.6  |     | 152752   | 151541.5 | 155913.2 |
| 670.4   | 646     | 678.1  |     | 154317.4 | 157710.4 | 157684.2 |
| 632.2   | 626.6   | 640.9  |     | 157424.9 | 160417.9 | 156512.8 |
| 616.6   | 643.5   | 652.4  |     | 154624.7 | 152263.3 | 156924.1 |

| ite10^6    | rec10^6    | rr10^6     |     | ite       | rec        | rr        |
| ---------- | ---------- | ---------- | --- | --------- | ---------- | --------- |
| 24668279.5 | 24756626.9 | 24845463.9 |     | 246682795 | 247566269, | 248454639 |
| 24833954.3 | 24820813.8 | 24986810.1 |     | 248339543 | 248208138  | 249868101 |
| 25267243.7 | 24860456.7 | 25062822.6 |     | 252672437 | 248604567  | 250628226 |
| 24984448.1 | 24822575.4 | 25021892.9 |     | 249844481 | 248225754  | 250218929 |
| 25082926.3 | 24644670.9 | 24882422.8 |     | 250829263 | 246446709  | 248824228 |
| 25067892.1 | 24874004   | 25063528.1 |     | 250678921 | 248740040  | 250635281 |
| 25186908.4 | 24961933   | 24957468.9 |     | 251869084 | 249619330  | 249574689 |
| 24953885.8 | 24979921.3 | 24825369.3 |     | 249538858 | 249799213  | 248253693 |
| 24756064.3 | 24987098.9 | 24985138.4 |     | 247560643 | 249870989  | 249851384 |
| 24922159.9 | 25278697.8 | 24991848.7 |     | 249221599 | 252786978  | 249918487 |

### 그래프

10^2 사이즈의 배열의 경우 연산 횟수 그래프

![스크린샷 2023-04-29 오후 10.16.42.png](img/1.png)

10^4 사이즈의 배열의 경우 연산 횟수 그래프

![스크린샷 2023-04-29 오후 10.20.01.png](img/2.png)

10^6 사이즈의 배열의 경우 연산 횟수 그래프

![스크린샷 2023-04-29 오후 10.21.56.png](img/3.png)

전체 연산 횟수 그래프

![스크린샷 2023-04-29 오후 10.23.05.png](img/4.png)

### 시간복잡도

랜덤피벗을 기준으로 보자면 매번 파티션을 나눌때 랜덤한 피벗을 잡아서 재귀한다는 의미는 우리가 파티션을 나눌때 최악의 경우의 수인 최대값이랑 최소값을 피벗으로 잡는 경우가 0에 수렴하게 된다는 의미이다.

그렇기에 퀵정렬의 이상적인 시간복잡도인 O(nlogn)이 나와야 한다.

n이 10^2일때 200, 10^4일때 40000 10^6일때 6000000정도이고

위에 나온 실측 데이터들을 보자면 10^2일때 700정도, 10^4일때 160000 정도, 10^6일때 25000000정도 나오므로 대충 4nlogn 정도가 나오게 된다.

n^2보다 작으므로 O(nlogn)임을 증명했다.

### 결론

반복문으로 만든 퀵정렬이 재귀적으로 실행된 퀵정렬이랑 실행횟수가 비슷한게 신기하였지만 구현이 어려울뿐 결국 실행 방식은 같기 때문에 비슷한 횟수로 나온다고 생각된다.

그리고 랜덤피벗으로 하였을시 처음에 정말 랜덤한 피벗만 정하고 그 피벗을 마지막 원소로 옮겨서 나머지 연산을 똑같이 하니 시행횟수가 거의 비슷했다. 분명 랜덤 한 원소를 피벗으로 잡고 돌렸는데 이렇게 결과가 나오니 당황했다.

하지만 생각해보면 결국엔 랜덤해서 얻는 값을 피벗으로 잡는다고 하더라도 결국엔 랜덤한 값이랑 랜덤한 값이랑 바꾸고 같은 방식으로 재귀하므로 같은 값이 나오는게 맞다.

그렇기에 생각하건데 랜덤한 피벗값을 잡는것은 실제 데이터가 어떤것이 들어올지 모르므로 시작값을 피벗을 잡을시 대부분의 데이터가 앞에 최소값이 많이 분포한 데이터라든지 끝값을 피벗으로 잡을시 대부분의 데이터가 뒤에 최대값이 많이 분포한 데이터같은 경우보다 효율이 좋다는 것을 알게 되었다.
